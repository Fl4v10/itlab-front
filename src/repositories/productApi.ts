/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.2.3.0 (NJsonSchema v10.1.5.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import moment from "moment";

export interface IProductApi {
	/**
	 * @param term (optional)
	 * @return Success
	 */
	searchProducts(term?: string | null | undefined): Promise<ProductViewModel[]>;
	/**
	 * @return Success
	 */
	getProduct(id: number): Promise<ProductViewModel>;
	/**
	 * @param model (optional)
	 * @return Success
	 */
	updateProduct(
		id: number,
		model?: ProductViewModel | null | undefined
	): Promise<ProductViewModel>;
	/**
	 * @return Success
	 */
	deleteProduct(id: number): Promise<void>;
	/**
	 * @param model (optional)
	 * @return Success
	 */
	saveProduct(
		model?: ProductViewModel | null | undefined
	): Promise<ProductViewModel>;
}

export class ProductApi implements IProductApi {
	private http: {
		fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
	};
	private baseUrl: string;
	protected jsonParseReviver:
		| ((key: string, value: any) => any)
		| undefined = undefined;

	constructor(
		baseUrl?: string,
		http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
	) {
		this.http = http ? http : <any>window;
		this.baseUrl = baseUrl ? baseUrl : "";
	}

	/**
	 * @param term (optional)
	 * @return Success
	 */
	searchProducts(
		term?: string | null | undefined
	): Promise<ProductViewModel[]> {
		let url_ = this.baseUrl + "/api/Product/search";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(term);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Accept: "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processSearchProducts(_response);
		});
	}

	protected processSearchProducts(
		response: Response
	): Promise<ProductViewModel[]> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then(_responseText => {
				let result200: any = null;
				let resultData200 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200)
						result200!.push(ProductViewModel.fromJS(item));
				}
				return result200;
			});
		} else if (status === 400) {
			return response.text().then(_responseText => {
				let result400: any = null;
				let resultData400 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver);
				result400 = ProblemDetails.fromJS(resultData400);
				return throwException(
					"Bad Request",
					status,
					_responseText,
					_headers,
					result400
				);
			});
		} else if (status === 401) {
			return response.text().then(_responseText => {
				let result401: any = null;
				let resultData401 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver);
				result401 = ProblemDetails.fromJS(resultData401);
				return throwException(
					"Unauthorized",
					status,
					_responseText,
					_headers,
					result401
				);
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then(_responseText => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<ProductViewModel[]>(<any>null);
	}

	/**
	 * @return Success
	 */
	getProduct(id: number): Promise<ProductViewModel> {
		let url_ = this.baseUrl + "/api/Product/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "GET",
			headers: {
				Accept: "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetProduct(_response);
		});
	}

	protected processGetProduct(response: Response): Promise<ProductViewModel> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then(_responseText => {
				let result200: any = null;
				let resultData200 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver);
				result200 = ProductViewModel.fromJS(resultData200);
				return result200;
			});
		} else if (status === 400) {
			return response.text().then(_responseText => {
				let result400: any = null;
				let resultData400 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver);
				result400 = ProblemDetails.fromJS(resultData400);
				return throwException(
					"Bad Request",
					status,
					_responseText,
					_headers,
					result400
				);
			});
		} else if (status === 401) {
			return response.text().then(_responseText => {
				let result401: any = null;
				let resultData401 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver);
				result401 = ProblemDetails.fromJS(resultData401);
				return throwException(
					"Unauthorized",
					status,
					_responseText,
					_headers,
					result401
				);
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then(_responseText => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<ProductViewModel>(<any>null);
	}

	/**
	 * @param model (optional)
	 * @return Success
	 */
	updateProduct(
		id: number,
		model?: ProductViewModel | null | undefined
	): Promise<ProductViewModel> {
		let url_ = this.baseUrl + "/api/Product/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(model);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Accept: "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processUpdateProduct(_response);
		});
	}

	protected processUpdateProduct(
		response: Response
	): Promise<ProductViewModel> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then(_responseText => {
				let result200: any = null;
				let resultData200 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver);
				result200 = ProductViewModel.fromJS(resultData200);
				return result200;
			});
		} else if (status === 400) {
			return response.text().then(_responseText => {
				let result400: any = null;
				let resultData400 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver);
				result400 = ProblemDetails.fromJS(resultData400);
				return throwException(
					"Bad Request",
					status,
					_responseText,
					_headers,
					result400
				);
			});
		} else if (status === 401) {
			return response.text().then(_responseText => {
				let result401: any = null;
				let resultData401 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver);
				result401 = ProblemDetails.fromJS(resultData401);
				return throwException(
					"Unauthorized",
					status,
					_responseText,
					_headers,
					result401
				);
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then(_responseText => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<ProductViewModel>(<any>null);
	}

	/**
	 * @return Success
	 */
	deleteProduct(id: number): Promise<void> {
		let url_ = this.baseUrl + "/api/Product/{id}";
		if (id === undefined || id === null)
			throw new Error("The parameter 'id' must be defined.");
		url_ = url_.replace("{id}", encodeURIComponent("" + id));
		url_ = url_.replace(/[?&]$/, "");

		let options_ = <RequestInit>{
			method: "DELETE",
			headers: {}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processDeleteProduct(_response);
		});
	}

	protected processDeleteProduct(response: Response): Promise<void> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then(_responseText => {
				return;
			});
		} else if (status === 401) {
			return response.text().then(_responseText => {
				let result401: any = null;
				let resultData401 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver);
				result401 = ProblemDetails.fromJS(resultData401);
				return throwException(
					"Unauthorized",
					status,
					_responseText,
					_headers,
					result401
				);
			});
		} else if (status === 304) {
			return response.text().then(_responseText => {
				return throwException("Redirect", status, _responseText, _headers);
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then(_responseText => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<void>(<any>null);
	}

	/**
	 * @param model (optional)
	 * @return Success
	 */
	saveProduct(
		model?: ProductViewModel | null | undefined
	): Promise<ProductViewModel> {
		let url_ = this.baseUrl + "/api/Product";
		url_ = url_.replace(/[?&]$/, "");

		const content_ = JSON.stringify(model);

		let options_ = <RequestInit>{
			body: content_,
			method: "POST",
			headers: {
				"Content-Type": "application/json",
				Accept: "application/json"
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processSaveProduct(_response);
		});
	}

	protected processSaveProduct(response: Response): Promise<ProductViewModel> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then(_responseText => {
				let result200: any = null;
				let resultData200 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver);
				result200 = ProductViewModel.fromJS(resultData200);
				return result200;
			});
		} else if (status === 400) {
			return response.text().then(_responseText => {
				let result400: any = null;
				let resultData400 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver);
				result400 = ProblemDetails.fromJS(resultData400);
				return throwException(
					"Bad Request",
					status,
					_responseText,
					_headers,
					result400
				);
			});
		} else if (status === 401) {
			return response.text().then(_responseText => {
				let result401: any = null;
				let resultData401 =
					_responseText === ""
						? null
						: JSON.parse(_responseText, this.jsonParseReviver);
				result401 = ProblemDetails.fromJS(resultData401);
				return throwException(
					"Unauthorized",
					status,
					_responseText,
					_headers,
					result401
				);
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then(_responseText => {
				return throwException(
					"An unexpected server error occurred.",
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<ProductViewModel>(<any>null);
	}
}

export class ProductViewModel implements IProductViewModel {
	id?: number | undefined;
	name?: string | undefined;
	value?: number | undefined;
	targetGender?: boolean | undefined;
	type?: EProductType | undefined;
	registerAt?: moment.Moment | undefined;

	constructor(data?: IProductViewModel) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data["id"];
			this.name = _data["name"];
			this.value = _data["value"];
			this.targetGender = _data["targetGender"];
			this.type = _data["type"];
			this.registerAt = _data["registerAt"]
				? moment(_data["registerAt"].toString())
				: <any>undefined;
		}
	}

	static fromJS(data: any): ProductViewModel {
		data = typeof data === "object" ? data : {};
		let result = new ProductViewModel();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {};
		data["id"] = this.id;
		data["name"] = this.name;
		data["value"] = this.value;
		data["targetGender"] = this.targetGender;
		data["type"] = this.type;
		data["registerAt"] = this.registerAt
			? this.registerAt.toISOString()
			: <any>undefined;
		return data;
	}
}

export interface IProductViewModel {
	id?: number | undefined;
	name?: string | undefined;
	value?: number | undefined;
	targetGender?: boolean | undefined;
	type?: EProductType | undefined;
	registerAt?: moment.Moment | undefined;
}

export enum EProductType {
	_House = "House",
	_Car = "Car",
	_Animal = "Animal"
}

export class ProblemDetails implements IProblemDetails {
	type?: string | undefined;
	title?: string | undefined;
	status?: number | undefined;
	detail?: string | undefined;
	instance?: string | undefined;

	constructor(data?: IProblemDetails) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property))
					(<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.type = _data["type"];
			this.title = _data["title"];
			this.status = _data["status"];
			this.detail = _data["detail"];
			this.instance = _data["instance"];
		}
	}

	static fromJS(data: any): ProblemDetails {
		data = typeof data === "object" ? data : {};
		let result = new ProblemDetails();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === "object" ? data : {};
		data["type"] = this.type;
		data["title"] = this.title;
		data["status"] = this.status;
		data["detail"] = this.detail;
		data["instance"] = this.instance;
		return data;
	}
}

export interface IProblemDetails {
	type?: string | undefined;
	title?: string | undefined;
	status?: number | undefined;
	detail?: string | undefined;
	instance?: string | undefined;
}

export class SwaggerException extends Error {
	message: string;
	status: number;
	response: string;
	headers: { [key: string]: any };
	result: any;

	constructor(
		message: string,
		status: number,
		response: string,
		headers: { [key: string]: any },
		result: any
	) {
		super();

		this.message = message;
		this.status = status;
		this.response = response;
		this.headers = headers;
		this.result = result;
	}

	protected isSwaggerException = true;

	static isSwaggerException(obj: any): obj is SwaggerException {
		return obj.isSwaggerException === true;
	}
}

function throwException(
	message: string,
	status: number,
	response: string,
	headers: { [key: string]: any },
	result?: any
): any {
	if (result !== null && result !== undefined) throw result;
	else throw new SwaggerException(message, status, response, headers, null);
}
